suppressPackageStartupMessages({
  library(GenomicRanges)
  library(rtracklayer)
  library(stringr)
  library(reshape2)
  library(readr)
  library(dplyr)
  library(optparse)
  library(parallel)
})
num_cores <- detectCores() - 3

#' Compute and filter hits based on the difference in the genomic start and end
#'
#' @param query first set of range
#' @param subject optional, second set of ranges
#' @param max_start max_end absolute max difference at the start and
#' end coordinates,
#' respectively
#' @return overlapping ranges given the constrain
#' @export
filter_hits_by_diff <- function(query,
                                subject = NULL,
                                max_start = 2,
                                max_end = 2) {
  stopifnot(is(query, "GRanges"))
  if (is.null(subject)) {
    hits <- findOverlaps(query)
    subject <- query
  } else {
    stopifnot(is(subject, "GRanges"))
    hits <- findOverlaps(query, subject)
  }
  query <- query[queryHits(hits)]
  subject <- subject[subjectHits(hits)]
  start_dif <- abs(start(query) - start(subject))
  end_dif <- abs(end(query) - end(subject))
  hits <- hits[start_dif <= max_start & end_dif <= max_end]
  hits
}

#' Creates exon by transcript list (ex_by_tx) and remove items
#' with a single exon
#'
#' @param gtf GRange file loaded with rtracklayer::import
#' @return  a list of exon by transcripts, excluding single exon trascripts
#' @export
filter_multi_exon <- function(gtf) {
  stopifnot(is(gtf, "GRanges"))

  ex <- subset(gtf, type == "exon")
  stopifnot(length(ex) > 0)

  # discard single exons transcripts
  multi_ex <- table(ex$transcript_id) > 1
  ex <- subset(ex, mcols(ex)$transcript_id %in% names(multi_ex[multi_ex]))
  ex_tx <- split(ex, ex$transcript_id)
  ex_tx
}

#' Compute a set of introns from GTF files
#'
#' @param gtf_path path to to the gtf file
#' @param read_gtf function to read the gtf_file
#' @return a GRange that obj with the introns named by their parent trancripts
#' @export

get_introns <- function(ex_tx) {
  stopifnot(is(ex_tx, "List"))

  introns <- psetdiff(unlist(range(ex_tx), use.names = FALSE), ex_tx)
  introns <- unlist(introns)
  introns
}

######
### this part aims to add two exons at the both end for each intron
### input: GRange for transcripts (lists of GRange), 
### output: (one - the next) exon-pair Grange (linked by identified intron)
### then start and end of GRange in eahc pair is the start of the first exon 
### and the end of the second exon
calc_overlaps <- function(ex_tx_sub) {
  # Generate the overlapping exon ranges
  overlap_starts <- start(ex_tx_sub)
  overlap_ends <- lead(end(ex_tx_sub))
  
  # Remove the NA generated by 'lead' for the last exon
  overlap_starts <- overlap_starts[-length(overlap_starts)]
  overlap_ends <- overlap_ends[-length(overlap_ends)]
  
  # Create a GRanges object for overlapping exons
  overlaps <- GRanges(
    seqnames = seqnames(ex_tx_sub)[seq_along(overlap_starts)],
    ranges = IRanges(start = overlap_starts, end = overlap_ends)
  )
  
  # Return the overlapping ranges
  return(overlaps)
}

get_introns_with_ex <- function(ex_tx) {
  stopifnot(is(ex_tx, "List"))
  introns_ex <- mclapply(ex_tx, calc_overlaps, mc.cores= num_cores)
  introns_ex <-GRangesList(introns_ex)
  introns_ex
}


get_introns_with_ex_V2 <-function(ex_tx){
    stopifnot(is(ex_tx, "List"))
    introns_ex <- endoapply(ex_tx, function(x){
        gr_ <- unique(sort(x))
        # start <- start(gr_[-length(gr_)])
        # end <- end(gr_[-1]) 
        gr_shifted <- gr_[-1]
        start(gr_shifted) <- start(gr_[-length(gr_)])
        end(gr_shifted) <- end(gr_[-1])
        gr_shifted
        })
    }
        

######DEBUGGING...
# get_gene_ex_mergesort <- function(gtf){
#     gene_exs <- lapply(gene_ids, function(gid) {
#       gene_gtf <- gtf[mcols(gtf)$gene_id == gid, ]
#       collapsed_exs_4gene <- reduce(gene_gtf)
#       sorted_exs_4gene <- sort(collapsed_exs_4gene)
#       exon_numbers <- seq_along(sorted_exs_4gene)
#       mcols(sorted_exs_4gene)$exon_number <- as.character(exon_numbers)
#       sorted_exs_4gene
#     })
#     }
process_gene <- function(gtf_split_by_gene){
    sorted_gtf <- unique(sort(gtf_split_by_gene, decreasing = FALSE))
    olaps <- findOverlaps(gtf_split_by_gene, sorted_gtf, type ="equal")
    mcols(sorted_gtf)$exon_number_before <- seq_along(sorted_gtf)
    mcols(gtf_split_by_gene)$exon_number_before <- subjectHits(olaps)
    reduced_sorted_gtf <- reduce(gtf_split_by_gene)
    overlaps <- findOverlaps(gtf_split_by_gene, reduced_sorted_gtf)
    mcols(gtf_split_by_gene)$exon_number_after <- subjectHits(overlaps)
    mcols(gtf_split_by_gene)$exon_coordinates <- as.character(gtf_split_by_gene)
    gtf_split_by_gene
}


get_gene_ex_mergesort <- function(gtf){
    ex <- subset(gtf, type == "exon")
    gtf_splitbygene <- split(ex, ex$gene_id)
    # unlisted_ex_tx <- unlist(ex_tx)
    # names(unlisted_ex_tx) <- NULL
    # ex_bygene <- split(unlisted_ex_tx, unlisted_ex_tx$gene_id)
    gene_ex_tx <- mclapply(gtf_splitbygene, process_gene, mc.cores = num_cores)
    #gene_ex_tx$coordinates <- as.character(gene_ex_tx)
    gene_ex_tx <-GRangesList(gene_ex_tx) 
    gene_ex_tx
}
#####

aggregate_annotation <- function(gr) {
  stopifnot(is(gr, "GRanges"))

  equal_hits <- findOverlaps(
    gr,
    type = "equal"
  )
  equal_hits <- as.data.frame(equal_hits)
  equal_hits <- igraph::graph_from_data_frame(equal_hits)
  equal_hits_groups <- stack(igraph::groups(igraph::clusters(equal_hits)))


  gr_ <- as.data.frame(mcols(gr))
  gr_$coordinates <- as.character(gr)
  gr_[as.numeric(equal_hits_groups$values), "group"] <- equal_hits_groups$ind
  gr_ <- aggregate(. ~ group, gr_, unique)
  gr <- GenomicRanges::GRanges(gr_$coordinates)
  mcols(gr) <- gr_
  gr
}

#' Fetch exons pairs for an intron
#'
#' @param introns_by_transcript list of introns by transcript
#' @return a data.frame with acceptor and donor exon number for an intron
#' @export
get_exon_number <- function(ex_tx) {
  stopifnot(is(ex_tx, "List"))

  exon_n_by_transcript <- lapply(ex_tx, function(x) embed(x$exon_number, 2))
  exon_number <- tidyr::unnest(
    tibble::enframe(exon_n_by_transcript),
    cols = "value"
  )

  exon_number
}

                                 
                                 
                                 
#' Corrects coordinates from alt GRange to ref GRange
#' by the most common start and end difference
#' @param ref reference GenomicRange
#' @param alt alternative GenomicRange
#' @return alt but corrected start and end coordinates
#' @export
integrate_coordinates <- function(ref, alt) {
  hits <- findOverlaps(ref, alt)
  if (length(hits) >0) {
    query <- ref[queryHits(hits)]
    subject <- alt[subjectHits(hits)]
    start_diff <- start(query) - start(subject)
    start(alt) <- start(alt) + most_frequent(start_diff)
    end_diff <- end(query) - end(subject)
    end(alt) <- end(alt) + most_frequent(end_diff)
    return(alt)
  } else {
    return(GRanges())
  }
  print(most_frequent(start_diff))
  print(most_frequent(end_diff))
}
                                 
                                 
most_frequent <- function(.x) {
  as.numeric(names(which.max(table(.x))))
}
                                 

ex_rearrange_label <- function(x){
    res<- psetdiff(range((x)), GRangesList((x)))[[1]]
    mcols(res) <- mcols(x)[-1, -ncol(mcols(x))]
    res$exon_number <- apply(embed(x$exon_number, 2), 1, function(x) paste(x, collapse="-"))
    res$exon_number_before <- apply(embed(x$exon_number_before, 2), 1, function(x) paste(x, collapse="-"))
    res$exon_number_after <- apply(embed(x$exon_number_after, 2), 1, function(x) paste(x, collapse="-"))
    #res$transcript_id <- x$transcript_id
    res 
}

get_introns_V2 <- function(ex_tx) {

  stopifnot(is(ex_tx, "List"))
  introns <- mclapply(ex_tx, ex_rearrange_label, mc.cores = num_cores )
  #   introns <- GRangesList(introns)
  # introns <- unlist(introns)
  introns
}

option_list <- list(
  make_option(
    c("-a", "--annotation"),
    type = "character",
    default = "merged/merged.combined.gtf",
    help = "Path with glob character to Leafcutter result files.
    [default %default]",
    metavar = "character"
  ),
  make_option(
    c("-r", "--reference"),
    type = "character",
    default = "Human.GRCh38.v34.l1_5.ERCC.transcript.gtf",
    help = "Path to output file [default %default]",
    metavar = "character"
  ),
  make_option(
    c("-i", "--input"),
    type = "character",
    default = "{method}_junction_prep.csv",
    help = "Path to output file [default %default]",
    metavar = "character"
  ), 



  make_option(
    c("-o", "--output"),
    type = "character",
    default = "sj.csv",
    help = "Path to output file [default %default]",
    metavar = "character"
  )
)


opt <- parse_args(OptionParser(option_list = option_list))
#files <- strsplit(opt$input, ",")[[1]]
default_input <- str_glue(opt$input,method = c( "leafcutter", "majiq", "rmats")) %>% str_c(collapse = ",")
# print(default_input)

message("Loading input")

annotation_file = opt$annotation
reference_file = opt$reference

message("Processing de novo annotation")
gtf <- rtracklayer::import.gff2(annotation_file)
ref <- rtracklayer::import.gff2(reference_file)


ref_ex_tx <- filter_multi_exon(ref)
ref_introns <- get_introns(ref_ex_tx)
ref_introns <- ref_introns[width(ref_introns) > 2, ]


files <- strsplit(default_input, ",")[[1]]

majiq_idx <- grep("majiq", files)
leafcutter_idx <- grep("leafcutter", files)
rmats_idx <- grep("rmats", files)


rmats  = read.csv(files[[rmats_idx]])
leafcutter = read.csv(files[[leafcutter_idx]])
majiq = read.csv(files[[majiq_idx]])
# leafcutter$comparison <- paste0(leafcutter$comparison)
# majiq$comparison <- paste0(, majiq$comparison)
# rmats$comparison <- paste0('BIO2006152-10x-', rmats$comparison)
leafcutter <- rename(leafcutter, FDR = p.adjust)
majiq$FDR <- 1 - majiq$PdPSI
majiq$type <- 'NA'
majiq$ID <-  paste(
  majiq$lsv_id,
  ifelse(majiq$lsv_type == 'i', 'ir', ''),
  sep = ':'
)
# majiq$graph <- paste(majiq$geneSymbol, sub(".*([ts]:\\d+-\\d+).*", "\\1", majiq$lsv_id),sep = ':')
majiq$graph <- paste(
  majiq$geneSymbol,
  sub(".*([ts]:\\d+-\\d+).*", "\\1", majiq$lsv_id),
  ifelse(majiq$lsv_type == 'i', 'ir', ''),
  sep = ':'
)
leafcutter$graph <- 'NA'

if (nrow(rmats) ==0){
  message("Processing DJU method output")

    df <- list(
      majiq = majiq,
      leafcutter = leafcutter
    )

    df$leafcutter["score"] <- 1 - df$leafcutter$FDR
    df$majiq["score"] <- df$majiq$PdPSI
    df$majiq["type"] <- "NA"

}else {
  rmats$graph <- "NA"
  message("Processing DJU method output")

  df <- list(
    majiq = majiq,
    leafcutter = leafcutter,
    #junctionseq = read.csv(files[[junctionseq_idx]]),
    rmats = rmats
  )


  df$leafcutter["score"] <- 1 - df$leafcutter$FDR
  df$majiq["score"] <- df$majiq$PdPSI
  df$rmats["score"] <- 1 - df$rmats$FDR
  df$majiq["type"] <- "NA"
}

message("Proceding with integration")

gr <- lapply(df, function(x) {
  .gr <- GRanges(x)
  .gr <- .gr[width(.gr) > 2, ]
  if (!"type" %in% colnames(mcols(.gr))) {
    mcols(.gr)["type"] <- "NA"
  }
  mcols(.gr) <- mcols(.gr)[c("score", "comparison", "method", "PSI_1", 'PSI_2' , "ID", "type", "graph", "geneSymbol")]


  integrate_coordinates(ref_introns, .gr)
})

gr <- unlist(as(gr, "GRangesList"))
mcols(gr)$method <- names(gr)

mcols(gr)$method <- names(gr)
mcols(gr)$start <- start(gr)
mcols(gr)$end <- end(gr)
mcols(gr)$chr <- seqnames(gr)
mcols(gr)$strand <- strand(gr)
mcols(gr)$coordinates <- as.character(gr)

readr::write_csv(as.data.frame(mcols(gr)), opt$output)